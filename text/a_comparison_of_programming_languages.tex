A Comparison of Programming Languages: Rust vs. Go

    Our group chose two emerging languages that have seen a rise in popularity over the past couple of years. We give a comparison between Rust and Go, and see which is the better choice of language to work with. We will look at readability, writability, reliability, and cost as a rubric. 

% Rust has a very short history, having been unveiled in 2010, and only saw its first alpha release in 2012.
% Graydon Hoare was the lead developer and began work on Rust in 2006 as his own personal project, and in 2009 Mozilla (his employer) became involved with Rust's development.
% Rust was intended to be a ``safe, concurrent, practical language'', supporting pure-functional, concurrent-actor, imperative-procedural, and object-oriented styles. Rust is sponsored by both Mozilla and Samsung, and is developed and maintained by open-source community volunteers.

      

%     The goal of Rust is to be a good language for the creation of large client and server programs that run over the Internet. This has led to a feature set with an emphasis on safety, control of memory layout and concurrency. Performance of safe code is expected to be slower than C++ if performance is the only consideration, but to be comparable to C++ code that manually takes precautions comparable to what the Rust language mandates. Rust syntax is very similar to C & C++ but is semantically very different. Rust uses blocks of code delimited by curly braces, and control-flow keywords such as if, else, do, while, and for, but not all C or C++ keywords are present. Rust system is designed to be memory safe, and it does not permit null pointers or dangling pointers. Data values can only be initialized through a fixed set of forms, all of which require their inputs to be already initialized. A system of pointer lifetimes and freezing allows the compiler to prevent many types of error that are possible to write in C++, even when using its smart pointers; thus Rust claims that it ``prevents almost all crashes''. The object system within Rust is based around implementations, traits and structured types. Implementations fulfill a role similar to that of classes within other languages, and are defined with the impl keyword. Inheritance and polymorphism are provided by traits; they allow methods to be defined and mixed into implementations. Structured types are used to define fields. Implementations and traits cannot define fields themselves, and only traits can provide inheritance, in order to prevent the diamond inheritance problem of C++.
%    Just like Rust, Go was a personal and experimental project. Robert Griesemer, Rob Pike and Ken Thompson started sketching the goals for a new language on the white board on September 21, 2007. Within a few days the goals had settled into a plan to do something and a fair idea of what it would be. Design continued part-time in parallel with unrelated work. By January 2008, Ken had started work on a compiler with which to explore ideas; it generated C code as it's output. By mid-year the language had become a full-time project and had settled enough to attempt a production compiler. Russ Cox joined in late 2008 and helped move the language and libraries from prototype to reality. Go became a public open source project on November 10, 2009. Many people from the community have contributed ideas, discussions, and code. The reasoning behind the creation of Go was out of frustration with existing languages and environments for systems programming. Programming had become too difficult and the choice of languages was partly to blame. One had to choose efficient compilation, efficient execution, or ease of programming; all three were not available in the same mainstream language. Programmers who could were choosing ease over safety and efficiency by moving to dynamically typed languages such as Python and JavaScript rather than C++ or, to a lesser extent, Java.
%    Go looks a lot like C, but makes many changes aimed at conciseness, simplicity, and safety. Functions may return multiple, named values, and returning a result, err pair is the standard way to handle errors in Go. Go adds literal syntaxes for initializing struct parameters by name, and for initializing maps and slices. As an alternative to C's three-statement for loop, Go's range expressions allow concise iteration over arrays, slices, strings, and maps. In place of virtual inheritance, Go uses interfaces. An interface declaration is nothing but a list of required methods: for example, implementing io.Reader requires a Read method that takes a []byte and returns a count of bytes read and any error. Code calling Read needn’t know whether it's reading from an HTTP connection, a file, an in-memory buffer, or any other source. Go types don't declare which interfaces they implement: having the required methods is implementing the interface. In formal language, Go's interface system provides structural rather than nominal typing.  Go is a mixture of C/C++ and Java put in one language.
      
      Our overview on Go
      
Readability: 6
	Since Go is a C-like language, there are some obvious similarities to languages like C++ and Java. However, some of the things that make Go unique also makes it hard to read at a glance. The only loop structure is a for-loop, which can be modified in MANY different ways to provide various looping functions (such as the traditional while loop). A type can be declared explicitly (in the format \texttt{var <identifier> <type> = value}) or inferred (\texttt{identifier: = value}), which can lead to some confusion at first.
Writability: 5
	Go has some intuitive features like the \texttt{:=} operator (which is a shorthand variable declaration with inferred assignment) and multiple returns from a function. These make Go feel ``natural'' when writing code and it gives the programmer a sense of progress and accomplishment.
	However it seems for every convenience Go offers, there are two annoyances that plague the language. For example slices are, on the surface, very simple: arrays with variable sizes. However there are many slight caveats with slices that will trip up the programmer in their implementation (like the difference between \texttt{[0]a}, \texttt{a[0]}, and \texttt{b[0]} where \texttt{a} is a slice and \texttt{b} is an array).
Reliability: 9
	 Robert Griesemer, Rob Pike, and Ken Thompson wrote Go with reliability in mind. Every structure in the language is seemingly designed not to work unless used absolutely correctly. I had more trouble getting my code to compile than I did with bug fixing, simply because the language forced me to write ``correct'' code. For example, I used a method from the \texttt{os} packaged called \texttt{Open()} to open a file. This method actually returns two separate values: the opened file, and an error code. This actually FORCED me to implement error-handling code because otherwise, my code would not even compile!
Cost: 7
	While the language may come free of cost, programmers will definitely need to be trained in the language by someone who is already proficient. Go's website provides some tutorials and documentation, but you absolutely cannot rely on just these to become fluent. Even after completing the tutorial, I had to have my nose constantly in documentation or in a forum to understand what I was doing, right or wrong. This is something that is incredibly time consuming and in a professional environment, the man-hours expense would be unjustifiable.

Grade: 27/40
      	We really like Go, we think it's a language that is most definitely on the right track to completely replacing C/C++ and Java in the future. We can say this with confidence because the design of the language is most definitely ``smart'' in that good code is almost a guarantee in the language if you can successfully compile. Yet as well designed as it may be functionally, it's incredibly upsetting to see Go suffer from readability and writability issues that absolutely shouldn't be in modern languages. Ken Thompson saw Go as an opportunity to look at C++ and toss out everything considered outdated or absurdly obtuse, yet it feels as though in that process Go accumulated its own features that feel the same way.
      
      Our overview on Rust

Matthew F. Kevin M. Nicholas N. Luis S.

